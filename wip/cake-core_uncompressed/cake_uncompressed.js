// Do not edit this file; automatically generated by build.py.
"use strict";

Blockly.cake = new Blockly.Generator("cake");
Blockly.cake.C_VARIABLE_TYPES = [
    ["float", "float"],
    ["int", "int"],
    ["unsigned int", "unsigned int"],
    ["short", "short"],
    ["unsigned short", "unsigned short"],
    ["bool", "bool"]
];
Blockly.cake.C_GLOBAL_VARS = [];
Blockly.cake.addReservedWords(",alignas,alignof,and,and_eq,asm,auto,bitand,bitor,bool,break,case,catch,char,char16_t,char32_t,class,compl,const,constexpr,const_cast,continue,decltype,default,delete,do,double,dynamic_cast,else,enum,explicit,export,extern,false,float,for,friend,goto,if,inline,int,long,long double,long long,mutable,namespace,new,noexcept,not,not_eq,nullptr,operator,or,or_eq,private,protected,public,register,reinterpret_cast,return,short,signed,sizeof,static,static_assert,static_cast,struct,switch,template,this,thread_local,throw,true,try,typedef,typeid,typename,union,unsigned,using,virtual,void,volatile,wchar_t,while,xor,xor_eq,posix,game,api,PI,PI2,PI3,PI4,DEG2RAD,RAD2DEG,ZRMS,ZR2D,ZR3D,ALLIANCE");
Blockly.cake.ORDER_ATOMIC = 0;
Blockly.cake.ORDER_MEMBER = 2;
Blockly.cake.ORDER_FUNCTION_CALL = 2;
Blockly.cake.ORDER_INCREMENT = 3;
Blockly.cake.ORDER_DECREMENT = 3;
Blockly.cake.ORDER_LOGICAL_NOT = 3;
Blockly.cake.ORDER_BITWISE_NOT = 3;
Blockly.cake.ORDER_UNARY_PLUS = 3;
Blockly.cake.ORDER_UNARY_NEGATION = 3;
Blockly.cake.ORDER_MULTIPLICATION = 5;
Blockly.cake.ORDER_DIVISION = 5;
Blockly.cake.ORDER_MODULUS = 5;
Blockly.cake.ORDER_ADDITION = 6;
Blockly.cake.ORDER_SUBTRACTION = 6;
Blockly.cake.ORDER_BITWISE_SHIFT = 7;
Blockly.cake.ORDER_RELATIONAL = 8;
Blockly.cake.ORDER_EQUALITY = 9;
Blockly.cake.ORDER_BITWISE_AND = 10;
Blockly.cake.ORDER_BITWISE_XOR = 11;
Blockly.cake.ORDER_BITWISE_OR = 12;
Blockly.cake.ORDER_LOGICAL_AND = 13;
Blockly.cake.ORDER_LOGICAL_OR = 14;
Blockly.cake.ORDER_CONDITIONAL = 15;
Blockly.cake.ORDER_ASSIGNMENT = 15;
Blockly.cake.ORDER_COMMA = 17;
Blockly.cake.ORDER_NONE = 99;
Blockly.cake.INFINITE_LOOP_TRAP = null;
Blockly.cake.init = function() {
    Blockly.cake.definitions_ = Object.create(null);
    Blockly.cake.times_ = Object.create(null);
    Blockly.cake.functionNames_ = Object.create(null);
    if (Blockly.Variables) {
        Blockly.cake.variableDB_ ? Blockly.cake.variableDB_.reset() : Blockly.cake.variableDB_ = new Blockly.Names(Blockly.cake.RESERVED_WORDS_);
        var a = [],
            b = Blockly.Variables.allVariables();
        Blockly.Structure.allStructure();
        for (var c = 0; c < b.length; c++) "global" == b[c][3] && (a[c] = b[c][0] + b[c][1] + " " + Blockly.cake.variableDB_.getName(b[c][2],
            Blockly.Variables.NAME_TYPE) + ";");
        Blockly.cake.definitions_.variables = a.join("\n")
    }
};
Blockly.cake.finish = function(a) {
    a && (a = this.prefixLines(a, Blockly.cake.INDENT));
    a = "\n" + a;
    var b = [],
        c = [],
        d = [],
        e = [],
        f;
    for (f in Blockly.cake.definitions_) {
        var h = Blockly.cake.definitions_[f];
        f.match("include") ? b.push(h) : f.match("Func_declare") ? c.push(h) : f.match("define") ? d.push(h) : e.push(h)
    }
    b = b.join("\n") + "\n\n" + c.join("\n") + "\n\n" + d.join("\n");
    e = e.join("\n");
    return b.replace(/\n\n+/g, "\n\n").replace(/\n*$/, "\n") + a + e.replace(/\n\n+/g, "\n\n")
};
Blockly.cake.finishFull = function(a) {
    var b = [],
        c;
    for (c in Blockly.cake.definitions_) b.push(Blockly.cake.definitions_[c]);
    a = b.join("\n\n") + "\n\nvoid setPos(float x, float y, float z) {\n\tfloat pos[3];\n\tpos[0] = x; pos[1] = y; pos[2] = z;\n\tapi.setPositionTarget(pos);\n}\n\n" + a; - 1 === a.indexOf("//Begin page init\nvoid init() {\n") && (a = "void init() {}\n" + a);
    return a
};
Blockly.cake.scrubNakedValue = function(a) {
    return a + ";\n"
};
Blockly.cake.quote_ = function(a) {
    a = a.replace(/\\/g, "\\\\").replace(/'/g, "\\'").replace(/"/g, '\\"').replace(/\?/g, "\\?");
    return a = a.replace(/\\\\n/g, "\\n")
};
Blockly.cake.scrub_ = function(a, b) {
    if (null === b) return "";
    var c = "";
    if (!a.outputConnection || !a.outputConnection.targetConnection) {
        var d = a.getCommentText();
        d && (c += this.prefixLines(d, "// ") + "\n");
        for (var e = 0; e < a.inputList.length; e++) a.inputList[e].type == Blockly.INPUT_VALUE && (d = a.inputList[e].connection.targetBlock()) && (d = this.allNestedComments(d)) && (c += this.prefixLines(d, "// "))
    }
    e = a.nextConnection && a.nextConnection.targetBlock();
    e = this.blockToCode(e);
    return c + b + e
};
// Copyright 2012 Google Inc.  Apache License 2.0
Blockly.cake.text = {};
Blockly.cake.text = function(a) {
    return [Blockly.cake.quote_(a.getFieldValue("TEXT")), Blockly.cake.ORDER_ATOMIC]
};
Blockly.cake.text_join = function(a) {
    if (0 == a.itemCount_) return ["''", Blockly.cake.ORDER_ATOMIC];
    if (1 == a.itemCount_) {
        var b = Blockly.cake.valueToCode(a, "ADD0", Blockly.cake.ORDER_NONE) || "''";
        return ["String(" + b + ")", Blockly.cake.ORDER_FUNCTION_CALL]
    }
    if (2 == a.itemCount_) return b = Blockly.cake.valueToCode(a, "ADD0", Blockly.cake.ORDER_NONE) || "''", a = Blockly.cake.valueToCode(a, "ADD1", Blockly.cake.ORDER_NONE) || "''", ["String(" + b + ") + String(" + a + ")", Blockly.cake.ORDER_ADDITION];
    b = Array(a.itemCount_);
    for (var c = 0; c < a.itemCount_; c++) b[c] =
        Blockly.cake.valueToCode(a, "ADD" + c, Blockly.cake.ORDER_COMMA) || "''";
    b = "[" + b.join(",") + "].join('')";
    return [b, Blockly.cake.ORDER_FUNCTION_CALL]
};
Blockly.cake.text_append = function(a) {
    var b = Blockly.cake.variableDB_.getName(a.getFieldValue("VAR"), Blockly.Variables.NAME_TYPE);
    a = Blockly.cake.valueToCode(a, "TEXT", Blockly.cake.ORDER_NONE) || "''";
    return b + " = String(" + b + ") + String(" + a + ");\n"
};
Blockly.cake.text_length = function(a) {
    return [(Blockly.cake.valueToCode(a, "VALUE", Blockly.cake.ORDER_FUNCTION_CALL) || "''") + ".length", Blockly.cake.ORDER_MEMBER]
};
Blockly.cake.text_isEmpty = function(a) {
    return ["!" + (Blockly.cake.valueToCode(a, "VALUE", Blockly.cake.ORDER_MEMBER) || "''"), Blockly.cake.ORDER_LOGICAL_NOT]
};
Blockly.cake.text_indexOf = function(a) {
    var b = "FIRST" == a.getFieldValue("END") ? "indexOf" : "lastIndexOf",
        c = Blockly.cake.valueToCode(a, "FIND", Blockly.cake.ORDER_NONE) || "''";
    return [(Blockly.cake.valueToCode(a, "VALUE", Blockly.cake.ORDER_MEMBER) || "''") + "." + b + "(" + c + ") + 1", Blockly.cake.ORDER_MEMBER]
};
Blockly.cake.text_charAt = function(a) {
    var b = a.getFieldValue("WHERE") || "FROM_START",
        c = Blockly.cake.valueToCode(a, "AT", Blockly.cake.ORDER_UNARY_NEGATION) || "1";
    a = Blockly.cake.valueToCode(a, "VALUE", Blockly.cake.ORDER_MEMBER) || "''";
    switch (b) {
        case "FIRST":
            return [a + ".charAt(0)", Blockly.cake.ORDER_FUNCTION_CALL];
        case "LAST":
            return [a + ".slice(-1)", Blockly.cake.ORDER_FUNCTION_CALL];
        case "FROM_START":
            return c = Blockly.isNumber(c) ? parseFloat(c) - 1 : c + " - 1", [a + ".charAt(" + c + ")", Blockly.cake.ORDER_FUNCTION_CALL];
        case "FROM_END":
            return [a +
                ".slice(-" + c + ").charAt(0)", Blockly.cake.ORDER_FUNCTION_CALL
            ];
        case "RANDOM":
            return [Blockly.cake.provideFunction_("text_random_letter", ["function " + Blockly.cake.FUNCTION_NAME_PLACEHOLDER_ + "(text) {", "  var x = Math.floor(Math.random() * text.length);", "  return text[x];", "}"]) + "(" + a + ")", Blockly.cake.ORDER_FUNCTION_CALL]
    }
    throw "Unhandled option (text_charAt).";
};
Blockly.cake.text_getSubstring = function(a) {
    var b = Blockly.cake.valueToCode(a, "STRING", Blockly.cake.ORDER_MEMBER) || "''",
        c = a.getFieldValue("WHERE1"),
        d = a.getFieldValue("WHERE2"),
        e = Blockly.cake.valueToCode(a, "AT1", Blockly.cake.ORDER_NONE) || "1";
    a = Blockly.cake.valueToCode(a, "AT2", Blockly.cake.ORDER_NONE) || "1";
    return ["FIRST" == c && "LAST" == d ? b : Blockly.cake.provideFunction_("text_get_substring", ["function " + Blockly.cake.FUNCTION_NAME_PLACEHOLDER_ + "(text, where1, at1, where2, at2) {", "  function getAt(where, at) {",
        "    if (where == 'FROM_START') {", "      at--;", "    } else if (where == 'FROM_END') {", "      at = text.length - at;", "    } else if (where == 'FIRST') {", "      at = 0;", "    } else if (where == 'LAST') {", "      at = text.length - 1;", "    } else {", "      throw 'Unhandled option (text_getSubstring).';", "    }", "    return at;", "  }", "  at1 = getAt(where1, at1);", "  at2 = getAt(where2, at2) + 1;", "  return text.slice(at1, at2);", "}"
    ]) + "(" + b + ", '" + c + "', " + e + ", '" + d + "', " + a + ")", Blockly.cake.ORDER_FUNCTION_CALL]
};
Blockly.cake.text_changeCase = function(a) {
    var b = {
        UPPERCASE: ".toUpperCase()",
        LOWERCASE: ".toLowerCase()",
        TITLECASE: null
    } [a.getFieldValue("CASE")];
    b ? (a = Blockly.cake.valueToCode(a, "TEXT", Blockly.cake.ORDER_MEMBER) || "''", a += b) : (b = Blockly.cake.provideFunction_("text_toTitleCase", ["function " + Blockly.cake.FUNCTION_NAME_PLACEHOLDER_ + "(str) {", "  return str.replace(/\\S+/g,", "      function(txt) {return txt[0].toUpperCase() + txt.substring(1).toLowerCase();});", "}"]), a = Blockly.cake.valueToCode(a, "TEXT", Blockly.cake.ORDER_NONE) ||
        "''", a = b + "(" + a + ")");
    return [a, Blockly.cake.ORDER_FUNCTION_CALL]
};
Blockly.cake.text_trim = function(a) {
    var b = {
        LEFT: ".trimLeft()",
        RIGHT: ".trimRight()",
        BOTH: ".trim()"
    } [a.getFieldValue("MODE")];
    return [(Blockly.cake.valueToCode(a, "TEXT", Blockly.cake.ORDER_MEMBER) || "''") + b, Blockly.cake.ORDER_FUNCTION_CALL]
};
Blockly.cake.text_print = function(a) {
    return "window.alert(" + (Blockly.cake.valueToCode(a, "TEXT", Blockly.cake.ORDER_NONE) || "''") + ");\n"
};
Blockly.cake.text_prompt = function(a) {
    var b = "window.prompt(" + Blockly.cake.quote_(a.getFieldValue("TEXT")) + ")";
    "NUMBER" == a.getFieldValue("TYPE") && (b = "parseFloat(" + b + ")");
    return [b, Blockly.cake.ORDER_FUNCTION_CALL]
};
Blockly.cake.text_prompt_ext = function(a) {
    var b = "window.prompt(" + (Blockly.cake.valueToCode(a, "TEXT", Blockly.cake.ORDER_NONE) || "''") + ")";
    "NUMBER" == a.getFieldValue("TYPE") && (b = "parseFloat(" + b + ")");
    return [b, Blockly.cake.ORDER_FUNCTION_CALL]
};
Blockly.cake.variables = {};
Blockly.cake.define_get = function(a) {
    a = Blockly.cake.variableDB_.getName(a.getFieldValue("VAR"), Blockly.Variables.NAME_TYPE);
    a = Blockly.Blocks.checkUnselect(a);
    return [a, Blockly.cake.ORDER_ATOMIC]
};
Blockly.cake.define_declare = function(a) {
    var b = Blockly.cake.valueToCode(a, "VALUE", Blockly.cake.ORDER_ASSIGNMENT) || "0",
        c = Blockly.cake.variableDB_.getName(a.getFieldValue("VAR"), Blockly.Variables.NAME_TYPE); - 1 == Blockly.Blocks.checkLegalName(Blockly.Msg.VARIABLES_ILLEGALNAME, c) && this.initVar();
    a = Blockly.cake.scrub_(a, "#define " + c + " " + b);
    Blockly.cake.definitions_["define_" + c] = a;
    return null
};
Blockly.cake.variables_get = function(a) {
    a = Blockly.cake.variableDB_.getName(a.getFieldValue("VAR"), Blockly.Variables.NAME_TYPE);
    a = Blockly.Blocks.checkUnselect(a);
    return [a, Blockly.cake.ORDER_ATOMIC]
};
Blockly.cake.variables_set = function(a) {
    var b = Blockly.cake.valueToCode(a, "VALUE", Blockly.cake.ORDER_ASSIGNMENT) || "0";
    a = Blockly.cake.variableDB_.getName(a.getFieldValue("VAR"), Blockly.Variables.NAME_TYPE);
    a = Blockly.Blocks.checkUnselect(a);
    return a + " = " + b + ";\n"
};
Blockly.cake.variables_declare = function(a) {
    var b = Blockly.cake.valueToCode(a, "VALUE", Blockly.cake.ORDER_ASSIGNMENT) || "0",
        c = Blockly.cake.variableDB_.getName(a.getFieldValue("VAR"), Blockly.Variables.NAME_TYPE);
    a = a.getFieldValue("TYPES"); - 1 == Blockly.Blocks.checkLegalName(Blockly.Msg.VARIABLES_ILLEGALNAME, c) && this.initVar();
    return a + " " + c + " = " + b + ";\n"
};
Blockly.cake.variables_pointer_get = function(a) {
    a = Blockly.cake.variableDB_.getName(a.getFieldValue("VAR"), Blockly.Variables.NAME_TYPE);
    a = Blockly.Blocks.checkUnselect(a);
    return [a, Blockly.cake.ORDER_ATOMIC]
};
Blockly.cake.variables_pointer_set = function(a) {
    var b = Blockly.cake.valueToCode(a, "VALUE", Blockly.cake.ORDER_ASSIGNMENT) || "0";
    a = Blockly.cake.valueToCode(a, "VAR", Blockly.cake.ORDER_ASSIGNMENT);
    a = Blockly.Blocks.checkUnselect(a);
    return a + " = " + b + ";\n"
};
Blockly.cake.variables_pointer_declare = function(a) {
    var b = Blockly.cake.valueToCode(a, "VALUE", Blockly.cake.ORDER_ASSIGNMENT) || "0",
        c = Blockly.cake.variableDB_.getName(a.getFieldValue("VAR"), Blockly.Variables.NAME_TYPE),
        d = a.getFieldValue("TYPES");
    if ("*" == a.getFieldValue("ITERATION") || "**" == a.getFieldValue("ITERATION") || "***" == a.getFieldValue("ITERATION")) a = a.getFieldValue("ITERATION");
    else return window.alert("please confirm asterisk. that must be among *, **, and  ***."), 0; - 1 == Blockly.Blocks.checkLegalName(Blockly.Msg.VARIABLES_ILLEGALNAME,
        c) && this.initVar();
    return d + a + " " + c + " = " + b + ";\n"
};
Blockly.cake["variables_pointer_&"] = function(a) {
    return ["&" + Blockly.cake.valueToCode(a, "VALUE", Blockly.cake.ORDER_ASSIGNMENT), Blockly.cake.ORDER_ATOMIC]
};
Blockly.cake["variables_pointer_*"] = function(a) {
    return ["*" + Blockly.cake.valueToCode(a, "VALUE", Blockly.cake.ORDER_ASSIGNMENT), Blockly.cake.ORDER_ATOMIC]
};
Blockly.cake.variables_array_get = function(a) {
    var b = Blockly.cake.variableDB_.getName(a.getFieldValue("VAR"), Blockly.Variables.NAME_TYPE);
    b = Blockly.Blocks.checkUnselect(b);
    var c = a.getFieldValue("LENGTH_1"),
        d = a.getFieldValue("LENGTH_2"),
        e = a.getFieldValue("LENGTH_3");
    0 == isNaN(c) && (c = "" == c ? -1 : 1 * c);
    0 == isNaN(d) && (d = "" == d ? -1 : 1 * d);
    0 == isNaN(e) && (e = "" == e ? -1 : 1 * e);
    var f = Blockly.Blocks.getWantedBlockArray("a"),
        h = Blockly.Blocks.getIndexArray(f, b);
    f = Blockly.Blocks.checkArrayIndex(c, h[0]);
    var g = Blockly.Blocks.checkArrayIndex(d,
        h[1]);
    h = Blockly.Blocks.checkArrayIndex(e, h[2]);
    if (0 == f && -1 != c || 0 == g && -1 != d || 0 == h && -1 != e) window.alert("\uc778\ub371\uc2a4 \ucd08\uacfc"), a.initIdx(f, g, h);
    else if (1 == f && 0 == g && 0 == h) var k = b + "[" + c + "]";
    else 1 == f && 1 == g && 0 == h ? k = b + "[" + c + "][" + d + "]" : 1 == f && 1 == g && 1 == h ? k = b + "[" + c + "][" + d + "][" + e + "]" : 0 == f && 0 == g && 0 == h ? (a = this.getFieldValue("VAR"), a = Blockly.FieldVariableArray.getBlockIdxLength(a), k = 1 == a ? b + "[]" : 2 == a ? b + "[][]" : b + "[][][]") : a.initIdx(f, g, h);
    return [k, Blockly.cake.ORDER_ATOMIC]
};
Blockly.cake.variables_array_set = function(a) {
    var b = Blockly.cake.valueToCode(a, "VALUE", Blockly.cake.ORDER_ASSIGNMENT) || "0",
        c = Blockly.cake.variableDB_.getName(a.getFieldValue("VAR"), Blockly.Variables.NAME_TYPE);
    c = Blockly.Blocks.checkUnselect(c);
    var d = a.getFieldValue("LENGTH_1"),
        e = a.getFieldValue("LENGTH_2"),
        f = a.getFieldValue("LENGTH_3");
    d = "" == d ? -1 : 1 * d;
    e = "" == e ? -1 : 1 * e;
    f = "" == f ? -1 : 1 * f;
    var h = Blockly.Blocks.getWantedBlockArray("a"),
        g = Blockly.Blocks.getIndexArray(h, c),
        k;
    h = Blockly.Blocks.checkArrayIndex(d,
        g[0]);
    var l = Blockly.Blocks.checkArrayIndex(e, g[1]);
    g = Blockly.Blocks.checkArrayIndex(f, g[2]);
    0 == h && -1 != d || 0 == l && -1 != e || 0 == g && -1 != f ? (window.alert("\uc778\ub371\uc2a4 \ucd08\uacfc"), a.initIdx(h, l, g)) : 1 == h && 0 == l ? k = c + "[" + d + "] = " + b + ";\n" : 1 == h && 1 == l && 0 == g ? k = c + "[" + d + "][" + e + "] = " + b + ";\n" : 1 == h && 1 == l && 1 == g ? k = c + "[" + d + "][" + e + "][" + f + "] = " + b + ";\n" : a.initIdx(h, l, g);
    return k
};
Blockly.cake.variables_array_declare = function(a) {
    var b = Blockly.cake.valueToCode(a, "VALUE", Blockly.cake.ORDER_ASSIGNMENT) || "0",
        c = Blockly.cake.variableDB_.getName(a.getFieldValue("VAR"), Blockly.Variables.NAME_TYPE),
        d = a.getFieldValue("TYPES"),
        e = a.getFieldValue("LENGTH_1"),
        f = a.getFieldValue("LENGTH_2");
    a = a.getFieldValue("LENGTH_3");
    var h;
    0 != e && 0 == f && 0 == a ? h = d + " " + c + "[" + e + "] = {" + b + "};\n" : 0 != e && 0 != f && 0 == a ? h = d + " " + c + "[" + e + "][" + f + "]  = {" + b + "};\n" : 0 != e && 0 != f && 0 != a && (h = d + " " + c + "[" + e + "][" + f + "][" + a + "] = {" +
        b + "};\n"); - 1 == Blockly.Blocks.checkLegalName(Blockly.Msg.VARIABLES_ILLEGALNAME, c) && this.initVar();
    return h
};
Blockly.cake.lists = {};
Blockly.cake.lists_create_empty = function(a) {
    return ["[]", Blockly.cake.ORDER_ATOMIC]
};
Blockly.cake.lists_create_with = function(a) {
    for (var b = Array(a.itemCount_), c = 0; c < a.itemCount_; c++) b[c] = Blockly.cake.valueToCode(a, "ADD" + c, Blockly.cake.ORDER_COMMA) || "null";
    b = "[" + b.join(", ") + "]";
    return [b, Blockly.cake.ORDER_ATOMIC]
};
Blockly.cake.lists_repeat = function(a) {
    var b = Blockly.cake.provideFunction_("lists_repeat", ["function " + Blockly.cake.FUNCTION_NAME_PLACEHOLDER_ + "(value, n) {", "  var array = [];", "  for (var i = 0; i < n; i++) {", "    array[i] = value;", "  }", "  return array;", "}"]),
        c = Blockly.cake.valueToCode(a, "ITEM", Blockly.cake.ORDER_COMMA) || "null";
    a = Blockly.cake.valueToCode(a, "NUM", Blockly.cake.ORDER_COMMA) || "0";
    return [b + "(" + c + ", " + a + ")", Blockly.cake.ORDER_FUNCTION_CALL]
};
Blockly.cake.lists_length = function(a) {
    return [(Blockly.cake.valueToCode(a, "VALUE", Blockly.cake.ORDER_FUNCTION_CALL) || "[]") + ".length", Blockly.cake.ORDER_MEMBER]
};
Blockly.cake.lists_isEmpty = function(a) {
    return ["!" + (Blockly.cake.valueToCode(a, "VALUE", Blockly.cake.ORDER_MEMBER) || "[]") + ".length", Blockly.cake.ORDER_LOGICAL_NOT]
};
Blockly.cake.lists_indexOf = function(a) {
    var b = "FIRST" == a.getFieldValue("END") ? "indexOf" : "lastIndexOf",
        c = Blockly.cake.valueToCode(a, "FIND", Blockly.cake.ORDER_NONE) || "''";
    return [(Blockly.cake.valueToCode(a, "VALUE", Blockly.cake.ORDER_MEMBER) || "[]") + "." + b + "(" + c + ") + 1", Blockly.cake.ORDER_MEMBER]
};
Blockly.cake.lists_getIndex = function(a) {
    var b = a.getFieldValue("MODE") || "GET",
        c = a.getFieldValue("WHERE") || "FROM_START",
        d = Blockly.cake.valueToCode(a, "AT", Blockly.cake.ORDER_UNARY_NEGATION) || "1";
    a = Blockly.cake.valueToCode(a, "VALUE", Blockly.cake.ORDER_MEMBER) || "[]";
    if ("FIRST" == c) {
        if ("GET" == b) return [a + "[0]", Blockly.cake.ORDER_MEMBER];
        if ("GET_REMOVE" == b) return [a + ".shift()", Blockly.cake.ORDER_MEMBER];
        if ("REMOVE" == b) return a + ".shift();\n"
    } else if ("LAST" == c) {
        if ("GET" == b) return [a + ".slice(-1)[0]", Blockly.cake.ORDER_MEMBER];
        if ("GET_REMOVE" == b) return [a + ".pop()", Blockly.cake.ORDER_MEMBER];
        if ("REMOVE" == b) return a + ".pop();\n"
    } else if ("FROM_START" == c) {
        d = Blockly.isNumber(d) ? parseFloat(d) - 1 : d + " - 1";
        if ("GET" == b) return [a + "[" + d + "]", Blockly.cake.ORDER_MEMBER];
        if ("GET_REMOVE" == b) return [a + ".splice(" + d + ", 1)[0]", Blockly.cake.ORDER_FUNCTION_CALL];
        if ("REMOVE" == b) return a + ".splice(" + d + ", 1);\n"
    } else if ("FROM_END" == c) {
        if ("GET" == b) return [a + ".slice(-" + d + ")[0]", Blockly.cake.ORDER_FUNCTION_CALL];
        if ("GET_REMOVE" == b || "REMOVE" == b) {
            c = Blockly.cake.provideFunction_("lists_remove_from_end",
                ["function " + Blockly.cake.FUNCTION_NAME_PLACEHOLDER_ + "(list, x) {", "  x = list.length - x;", "  return list.splice(x, 1)[0];", "}"]);
            d = c + "(" + a + ", " + d + ")";
            if ("GET_REMOVE" == b) return [d, Blockly.cake.ORDER_FUNCTION_CALL];
            if ("REMOVE" == b) return d + ";\n"
        }
    } else if ("RANDOM" == c) {
        c = Blockly.cake.provideFunction_("lists_get_random_item", ["function " + Blockly.cake.FUNCTION_NAME_PLACEHOLDER_ + "(list, remove) {", "  var x = Math.floor(Math.random() * list.length);", "  if (remove) {", "    return list.splice(x, 1)[0];", "  } else {",
            "    return list[x];", "  }", "}"
        ]);
        d = c + "(" + a + ", " + ("GET" != b) + ")";
        if ("GET" == b || "GET_REMOVE" == b) return [d, Blockly.cake.ORDER_FUNCTION_CALL];
        if ("REMOVE" == b) return d + ";\n"
    }
    throw "Unhandled combination (lists_getIndex).";
};
Blockly.cake.lists_setIndex = function(a) {
    function b() {
        if (c.match(/^\w+$/)) return "";
        var h = Blockly.cake.variableDB_.getDistinctName("tmp_list", Blockly.Variables.NAME_TYPE),
            g = "var " + h + " = " + c + ";\n";
        c = h;
        return g
    }
    var c = Blockly.cake.valueToCode(a, "LIST", Blockly.cake.ORDER_MEMBER) || "[]",
        d = a.getFieldValue("MODE") || "GET",
        e = a.getFieldValue("WHERE") || "FROM_START",
        f = Blockly.cake.valueToCode(a, "AT", Blockly.cake.ORDER_NONE) || "1";
    a = Blockly.cake.valueToCode(a, "TO", Blockly.cake.ORDER_ASSIGNMENT) || "null";
    if ("FIRST" ==
        e) {
        if ("SET" == d) return c + "[0] = " + a + ";\n";
        if ("INSERT" == d) return c + ".unshift(" + a + ");\n"
    } else if ("LAST" == e) {
        if ("SET" == d) return e = b(), e + (c + "[" + c + ".length - 1] = " + a + ";\n");
        if ("INSERT" == d) return c + ".push(" + a + ");\n"
    } else if ("FROM_START" == e) {
        f = Blockly.isNumber(f) ? parseFloat(f) - 1 : f + " - 1";
        if ("SET" == d) return c + "[" + f + "] = " + a + ";\n";
        if ("INSERT" == d) return c + ".splice(" + f + ", 0, " + a + ");\n"
    } else if ("FROM_END" == e) {
        e = b();
        if ("SET" == d) return e + (c + "[" + c + ".length - " + f + "] = " + a + ";\n");
        if ("INSERT" == d) return e + (c + ".splice(" +
            c + ".length - " + f + ", 0, " + a + ");\n")
    } else if ("RANDOM" == e) {
        e = b();
        f = Blockly.cake.variableDB_.getDistinctName("tmp_x", Blockly.Variables.NAME_TYPE);
        e += "var " + f + " = Math.floor(Math.random() * " + c + ".length);\n";
        if ("SET" == d) return e + (c + "[" + f + "] = " + a + ";\n");
        if ("INSERT" == d) return e + (c + ".splice(" + f + ", 0, " + a + ");\n")
    }
    throw "Unhandled combination (lists_setIndex).";
};
Blockly.cake.lists_getSublist = function(a) {
    var b = Blockly.cake.valueToCode(a, "LIST", Blockly.cake.ORDER_MEMBER) || "[]",
        c = a.getFieldValue("WHERE1"),
        d = a.getFieldValue("WHERE2"),
        e = Blockly.cake.valueToCode(a, "AT1", Blockly.cake.ORDER_NONE) || "1";
    a = Blockly.cake.valueToCode(a, "AT2", Blockly.cake.ORDER_NONE) || "1";
    return ["FIRST" == c && "LAST" == d ? b + ".concat()" : Blockly.cake.provideFunction_("lists_get_sublist", ["function " + Blockly.cake.FUNCTION_NAME_PLACEHOLDER_ + "(list, where1, at1, where2, at2) {", "  function getAt(where, at) {",
        "    if (where == 'FROM_START') {", "      at--;", "    } else if (where == 'FROM_END') {", "      at = list.length - at;", "    } else if (where == 'FIRST') {", "      at = 0;", "    } else if (where == 'LAST') {", "      at = list.length - 1;", "    } else {", "      throw 'Unhandled option (lists_getSublist).';", "    }", "    return at;", "  }", "  at1 = getAt(where1, at1);", "  at2 = getAt(where2, at2) + 1;", "  return list.slice(at1, at2);", "}"
    ]) + "(" + b + ", '" + c + "', " + e + ", '" + d + "', " + a + ")", Blockly.cake.ORDER_FUNCTION_CALL]
};
Blockly.cake.string = {};
Blockly.cake.library_string_strlen = function(a) {
    a = Blockly.cake.valueToCode(a, "VAR", Blockly.cake.ORDER_NONE) || '""';
    Blockly.cake.definitions_.include_cake_string = "#include <string.h>";
    return ["strlen(" + a + ")", Blockly.cake.ORDER_NONE]
};
Blockly.cake.library_string_strcat = function(a) {
    var b = Blockly.cake.valueToCode(a, "STR1", Blockly.cake.ORDER_NONE) || '""';
    a = Blockly.cake.valueToCode(a, "STR2", Blockly.cake.ORDER_NONE) || '""';
    Blockly.cake.definitions_.include_cake_string = "#include <string.h>";
    return ["strcat(" + b + ", " + a + ")", Blockly.cake.ORDER_NONE]
};
Blockly.cake.library_string_strcpy = function(a) {
    var b = Blockly.cake.valueToCode(a, "STR1", Blockly.cake.ORDER_NONE) || '""';
    a = Blockly.cake.valueToCode(a, "STR2", Blockly.cake.ORDER_NONE) || '""';
    Blockly.cake.definitions_.include_cake_string = "#include <string.h>";
    return ["strcpy(" + a + ", " + b + ")", Blockly.cake.ORDER_NONE]
};
Blockly.cake.library_string_strcmp = function(a) {
    var b = Blockly.cake.valueToCode(a, "STR1", Blockly.cake.ORDER_NONE) || '""';
    a = Blockly.cake.valueToCode(a, "STR2", Blockly.cake.ORDER_NONE) || '""';
    Blockly.cake.definitions_.include_cake_string = "#include <string.h>";
    return ["strcmp(" + b + ", " + a + ")", Blockly.cake.ORDER_NONE]
};
Blockly.cake.logic = {};
Blockly.cake.controls_if = function(a) {
    var b = 0,
        c = Blockly.cake.valueToCode(a, "IF" + b, Blockly.cake.ORDER_NONE) || "0",
        d = Blockly.cake.statementToCode(a, "DO" + b),
        e = "if (" + c + ") {\n" + d + "}";
    for (b = 1; b <= a.elseifCount_; b++) c = Blockly.cake.valueToCode(a, "IF" + b, Blockly.cake.ORDER_NONE) || "0", d = Blockly.cake.statementToCode(a, "DO" + b), e += " else if (" + c + ") {\n" + d + "}";
    a.elseCount_ && (d = Blockly.cake.statementToCode(a, "ELSE"), e += " else {\n" + d + "}");
    return e + "\n"
};
Blockly.cake.logic_compare = function(a) {
    var b = {
            EQ: "==",
            NEQ: "!=",
            LT: "<",
            LTE: "<=",
            GT: ">",
            GTE: ">="
        } [a.getFieldValue("OP")],
        c = "==" == b || "!=" == b ? Blockly.cake.ORDER_EQUALITY : Blockly.cake.ORDER_RELATIONAL,
        d = Blockly.cake.valueToCode(a, "A", c) || "0";
    a = Blockly.cake.valueToCode(a, "B", c) || "0";
    return [d + " " + b + " " + a, c]
};
Blockly.cake.logic_operation = function(a) {
    var b = "AND" == a.getFieldValue("OP") ? "&&" : "||",
        c = "&&" == b ? Blockly.cake.ORDER_LOGICAL_AND : Blockly.cake.ORDER_LOGICAL_OR,
        d = Blockly.cake.valueToCode(a, "A", c);
    a = Blockly.cake.valueToCode(a, "B", c);
    if (d || a) {
        var e = "&&" == b ? "1" : "0";
        d || (d = e);
        a || (a = e)
    } else a = d = "0";
    return [d + " " + b + " " + a, c]
};
Blockly.cake.logic_negate = function(a) {
    var b = Blockly.cake.ORDER_LOGICAL_NOT;
    return ["!" + (Blockly.cake.valueToCode(a, "BOOL", b) || "1"), b]
};
Blockly.cake.logic_boolean = function(a) {
    return ["TRUE" == a.getFieldValue("BOOL") ? "1" : "0", Blockly.cake.ORDER_ATOMIC]
};
Blockly.cake.logic_null = function(a) {
    return ["null", Blockly.cake.ORDER_ATOMIC]
};
Blockly.cake.logic_ternary = function(a) {
    var b = Blockly.cake.valueToCode(a, "IF", Blockly.cake.ORDER_CONDITIONAL) || "0",
        c = Blockly.cake.valueToCode(a, "THEN", Blockly.cake.ORDER_CONDITIONAL) || "null";
    a = Blockly.cake.valueToCode(a, "ELSE", Blockly.cake.ORDER_CONDITIONAL) || "null";
    return [b + " ? " + c + " : " + a, Blockly.cake.ORDER_CONDITIONAL]
};
Blockly.cake.controls_switch = function(a) {
    var b = 0,
        c = Blockly.cake.valueToCode(a, "SWITCH", Blockly.cake.ORDER_NONE) || "0",
        d = Blockly.cake.valueToCode(a, "CASE" + b, Blockly.cake.ORDER_NONE) || b,
        e = Blockly.cake.statementToCode(a, "DO" + b);
    b = Blockly.cake.statementToCode(a, "DEFAULT");
    c = "switch (" + c + ") {\ndefault :\n" + b + "\ncase " + d + " : \n" + e;
    for (b = 1; b <= a.caseCount_; b++) d = Blockly.cake.valueToCode(a, "CASE" + b, Blockly.cake.ORDER_NONE) || b, e = Blockly.cake.statementToCode(a, "DO" + b), c += "\ncase " + d + " : \n" + e;
    return c + "\n"
};
Blockly.cake.controls_switch_break = function(a) {
    return "break;\n"
};
Blockly.cake.math = {};
Blockly.cake.math_number = function(a) {
    return [parseFloat(a.getFieldValue("NUM")), Blockly.cake.ORDER_ATOMIC]
};
Blockly.cake.math_arithmetic = function(a) {
    var b = {
            ADD: [" + ", Blockly.cake.ORDER_ADDITION],
            MINUS: [" - ", Blockly.cake.ORDER_SUBTRACTION],
            MULTIPLY: [" * ", Blockly.cake.ORDER_MULTIPLICATION],
            DIVIDE: [" / ", Blockly.cake.ORDER_DIVISION]
        } [a.getFieldValue("OP")],
        c = b[0];
    b = b[1];
    var d = Blockly.cake.valueToCode(a, "A", b) || "0";
    a = Blockly.cake.valueToCode(a, "B", b) || "0";
    return ["(" + d + c + a + ")", b]
};
Blockly.cake.math_modulo = function(a) {
    var b = Blockly.cake.valueToCode(a, "DIVIDEND", Blockly.cake.ORDER_MODULUS) || "0";
    a = Blockly.cake.valueToCode(a, "DIVISOR", Blockly.cake.ORDER_MODULUS) || "0";
    return [b + " % " + a, Blockly.cake.ORDER_MODULUS]
};
Blockly.cake.library_math_abs = function(a) {
    a = Blockly.cake.valueToCode(a, "VAR", Blockly.cake.ORDER_NONE) || "''";
    Blockly.cake.definitions_.include_cake_math = "#include <math.h>";
    return ["abs(" + a + ")", Blockly.cake.ORDER_NONE]
};
Blockly.cake.library_math_trig = function(a) {
    var b = a.getFieldValue("OP");
    a = Blockly.cake.valueToCode(a, "NUM", Blockly.cake.ORDER_NONE) || "0";
    switch (b) {
        case "SIN":
            b = "sin(" + a + ")";
            break;
        case "COS":
            b = "cos(" + a + ")";
            break;
        case "TAN":
            b = "tan(" + a + ")";
            break;
        default:
            throw "Unknown math operator: " + b;
    }
    Blockly.cake.definitions_.include_cake_math = "#include <math.h>";
    return [b, Blockly.cake.ORDER_NONE]
};
Blockly.cake.library_math_logs = function(a) {
    var b = a.getFieldValue("OP");
    a = Blockly.cake.valueToCode(a, "NUM", Blockly.cake.ORDER_NONE) || "0";
    switch (b) {
        case "LOG":
            b = "log(" + a + ")";
            break;
        case "LOG10":
            b = "log10(" + a + ")";
            break;
        case "LOG2":
            b = "log2(" + a + ")";
            break;
        default:
            throw "Unknown math operator: " + b;
    }
    Blockly.cake.definitions_.include_cake_math = "#include <math.h>";
    return [b, Blockly.cake.ORDER_NONE]
};
Blockly.cake.library_math_pow = function(a) {
    var b = Blockly.cake.valueToCode(a, "BASE", Blockly.cake.ORDER_NONE) || "''";
    a = Blockly.cake.valueToCode(a, "EXPO", Blockly.cake.ORDER_NONE) || "''";
    Blockly.cake.definitions_.include_cake_math = "#include <math.h>";
    return ["pow(" + b + "," + a + ")", Blockly.cake.ORDER_NONE]
};
Blockly.cake.library_math_exp = function(a) {
    a = Blockly.cake.valueToCode(a, "EXPO", Blockly.cake.ORDER_NONE) || "''";
    Blockly.cake.definitions_.include_cake_math = "#include <math.h>";
    return ["exp(" + a + ")", Blockly.cake.ORDER_NONE]
};
Blockly.cake.library_math_sqrt = function(a) {
    a = Blockly.cake.valueToCode(a, "VAR", Blockly.cake.ORDER_NONE) || "''";
    Blockly.cake.definitions_.include_cake_math = "#include <math.h>";
    return ["sqrt(" + a + ")", Blockly.cake.ORDER_NONE]
};
Blockly.cake.library_math_round = function(a) {
    var b = a.getFieldValue("OP");
    a = Blockly.cake.valueToCode(a, "NUM", Blockly.cake.ORDER_NONE) || "''";
    switch (b) {
        case "ROUND":
            b = "round(" + a + ")";
            break;
        case "CEIL":
            b = "ceil(" + a + ")";
            break;
        case "FLOOR":
            b = "floor(" + a + ")";
            break;
        case "TRUNC":
            b = "trunc(" + a + ")";
            break;
        default:
            throw "Unknown math operator: " + b;
    }
    Blockly.cake.definitions_.include_cake_math = "#include <math.h>";
    return [b, Blockly.cake.ORDER_NONE]
};
Blockly.cake.library_math_numcheck = function(a) {
    var b = a.getFieldValue("CONDITIONS");
    a = Blockly.cake.valueToCode(a, "VAR", Blockly.cake.ORDER_NONE) || "''";
    switch (b) {
        case "ISFINITE":
            b = "isfinite(" + a + ")";
            break;
        case "ISINF":
            b = "isinf(" + a + ")";
            break;
        case "SIGNBIT":
            b = "signbit(" + a + ")";
            break;
        case "ISNAN":
            b = "isnan(" + a + ")";
            break;
        default:
            throw "Unknown math operator: " + b;
    }
    Blockly.cake.definitions_.include_cake_math = "#include <math.h>";
    return [b, Blockly.cake.ORDER_NONE]
};
Blockly.cake.library_math_numcompare = function(a) {
    var b = a.getFieldValue("CONDITIONS"),
        c = Blockly.cake.valueToCode(a, "VAR1", Blockly.cake.ORDER_NONE) || "''";
    a = Blockly.cake.valueToCode(a, "VAR2", Blockly.cake.ORDER_NONE) || "''";
    switch (b) {
        case "ISGREATER":
            b = "isgreater(" + c + "," + a + ")";
            break;
        case "ISLESS":
            b = "isless(" + c + "," + a + ")";
            break;
        case "ISGREQ":
            b = "isgreaterequal(" + c + "," + a + ")";
            break;
        case "ISLEEQ":
            b = "islessequal(" + c + "," + a + ")";
            break;
        case "ISLEGR":
            b = "islessgreater(" + c + "," + a + ")";
            break;
        case "ISUNORDER":
            b = "isunordered(" +
                c + "," + a + ")";
            break;
        default:
            throw "Unknown math operator: " + b;
    }
    Blockly.cake.definitions_.include_cake_math = "#include <math.h>";
    return [b, Blockly.cake.ORDER_NONE]
};
Blockly.cake.stdio = {};
Blockly.cake.library_stdio_printf = function(a) {
    for (var b, c, d = "", e = "", f = 0; f <= a.printAddCount_; f++) {
        b = Blockly.cake.valueToCode(a, "VAR" + f, Blockly.cake.ORDER_NONE) || "";
        c = a.inputList[f].connection;
        var h = c.targetBlock();
        if (h) {
            var g = h.type;
            "math_arithmetic" == g || "math_modulo" == g || "library_math_abs" == g || "library_math_trig" == g || "library_math_logs" == g || "library_math_pow" == g || "library_math_exp" == g || "library_math_sqrt" == g || "library_math_round" == g || "library_string_strlen" == g || "library_stdlib_rand" == g || "library_stdlib_number_forRandScope1" ==
                g || "library_stdlib_number_forRandScope100" == g || "library_stdlib_sizeof_forMalloc" == g || "library_stdlib_arithmetic_forMalloc" == g || "library_stdlib_number_forMalloc" == g ? (d += "%d", e += ", " + b) : "library_string_strcat" == g || "library_string_strcpy" == g || "library_string_strcmp" == g ? (d += "%s", e += ", " + b) : "library_stdlib_convert" == g ? (-1 != b.indexOf("atoi(") ? d += "%d" : -1 != b.indexOf("atof(") && (d += "%f"), e += ", " + b) : "variables_array_get" == g ? (c = b.split("["), c = Blockly.cake.varTypeCheckInPrintScan(c[0]), "" == c ? d += b : (d += c, e += ", " +
                    b)) : "variables_pointer_get" == g ? (d += "%p", e += ", " + b) : "variables_pointer_&" == g ? h.inputList[0].connection.targetBlock() && (b = Blockly.cake.valueToCode(h, "VALUE", Blockly.cake.ORDER_NONE) || "", d += "%p", e += ", &" + b) : "variables_pointer_*" == g ? h.inputList[0].connection.targetBlock() && (b = Blockly.cake.valueToCode(h, "VALUE", Blockly.cake.ORDER_NONE) || "", 0 <= b.indexOf("*") && h.inputList[0].connection.targetBlock().inputList[0].connection.targetBlock() ? (b = Blockly.cake.valueToCode(h.inputList[0].connection.targetBlock(),
                    "VALUE", Blockly.cake.ORDER_NONE) || "", c = Blockly.cake.pointerTypeCheckInPrint(b, !0), "" == c ? d += b : (d += c, e += ", **" + b)) : (c = Blockly.cake.pointerTypeCheckInPrint(b, !1), "" == c ? d += b : (d += c, e += ", *" + b))) : "library_math_numcheck" == g || "library_math_numcompare" == g || "procedures_callreturn" == g || "logic_compare" == g || "logic_operation" == g || "logic_negate" == g || "logic_boolean" == g || "logic_null" == g || "logic_ternary" == g || "controls_switch" == g || "library_stdlib_rand_scope" == g || "library_stdlib_malloc" == g ? (c.isSuperior() ? c.targetBlock().setParent(null) :
                    c.sourceBlock_.setParent(null), c.sourceBlock_.bumpNeighbours_()) : (c = Blockly.cake.varTypeCheckInPrintScan(b), "" == c ? d += b : (d += c, e += ", " + b))
        }
    }
    Blockly.cake.definitions_.include_cake_stdio = "#include <stdio.h>";
    return ("" == e ? 'printf("' + d + '");' : 'printf("' + d + '"' + e + ");") + "\n"
};
Blockly.cake.library_stdio_text = function(a) {
    var b = Blockly.cake.quote_(a.getFieldValue("TEXT"));
    if (!a.getParent() || "library_stdio_printf" != a.getParent().type && "define_declare" != a.getParent().type && "comment" != a.getParent().type) b = 1 == b.length ? "'" + b + "'" : '"' + b + '"';
    return [b, Blockly.cake.ORDER_ATOMIC]
};
Blockly.cake.library_stdio_newLine = function() {
    return ["\\n", Blockly.cake.ORDER_NONE]
};
Blockly.cake.library_stdio_scanf = function(a) {
    for (var b, c, d = "", e = "", f = 0; f <= a.scanAddCount_; f++) {
        b = Blockly.cake.valueToCode(a, "VAR" + f, Blockly.cake.ORDER_NONE) || "";
        c = a.inputList[f].connection;
        var h = c.targetBlock();
        if (h) {
            var g = h.type;
            "variables_array_get" == g ? (h = b.split("["), c = Blockly.cake.arrTypeCheckInScan(h[0], c), "%s" == c ? (d += c, e += ", " + b) : (d += c, e += ", &" + b)) : "variables_pointer_get" == g ? (c = Blockly.cake.varTypeCheckInPrintScan(b), "%c" == c && (c = "%s"), d += c, e += ", " + b) : "variables_pointer_&" == g ? (c.isSuperior() ?
                c.targetBlock().setParent(null) : c.sourceBlock_.setParent(null), c.sourceBlock_.bumpNeighbours_()) : "variables_pointer_*" == g ? h.inputList[0].connection.targetBlock() && (b = Blockly.cake.valueToCode(h, "VALUE", Blockly.cake.ORDER_NONE) || "", c = Blockly.cake.varTypeCheckInPrintScan(b), "" == c ? d += b : (d += c, e += ", &*" + b)) : (c = Blockly.cake.varTypeCheckInPrintScan(b), d += c, e += ", &" + b)
        }
    }
    Blockly.cake.definitions_.include_cake_stdio = "#include <stdio.h>";
    return ("" == e ? 'scanf("' + d + '");' : 'scanf("' + d + '"' + e + ");") + "\n"
};
Blockly.cake.varTypeCheckInPrintScan = function(a) {
    for (var b = "", c = Blockly.Variables.allVariables(), d = 0; d < c.length; d++)
        if (a == c[d][2]) {
            a = c[d][0];
            "int" == a ? b = "%d" : "unsigned int" == a ? b = "%u" : "float" == a ? b = "%f" : "double" == a ? b = "%f" : "char" == a ? b = "%c" : "dbchar" == a && (b = "%s");
            break
        } return b
};
Blockly.cake.pointerTypeCheckInPrint = function(a, b) {
    var c = "",
        d = Blockly.Variables.allVariables();
    if (1 == b) {
        for (var e = 0; e < d.length; e++)
            if (a == d[e][2]) {
                var f = d[e][0];
                "dbint" == f ? c = "%d" : "dbunsigned int" == f ? c = "%u" : "dbfloat" == f ? c = "%f" : "dbdouble" == f ? c = "%f" : "dbchar" == f && (c = "%c");
                break
            } return c
    }
    for (e = 0; e < d.length; e++)
        if (a == d[e][2]) return f = d[e][0], "*" == d[e][5] ? "int" == f ? c = "%d" : "unsigned int" == f ? c = "%u" : "float" == f ? c = "%f" : "double" == f ? c = "%f" : "char" == f && (c = "%c") : c = "dbchar" == f ? "%s" : "%p", c
};
Blockly.cake.arrTypeCheckInScan = function(a, b) {
    for (var c = "", d = b.targetBlock(), e = Blockly.Blocks.getWantedBlockArray("a"), f = 0; f < e.length; f++) {
        var h = Blockly.FieldDropdown.prototype.getTypefromVars(e[f][2], 0),
            g = e[f][5][0],
            k = d.getInputIdxLength();
        if (g == k) {
            "int" == h ? c = "%d" : "unsigned int" == h ? c = "%u" : "float" == h ? c = "%f" : "double" == h ? c = "%f" : "char" == h ? c = "%c" : "dbchar" == h && (c = "%s");
            break
        } else if (g > k && "char" == e[f][0]) {
            c = "%s";
            break
        } else b.isSuperior() ? b.targetBlock().setParent(null) : b.sourceBlock_.setParent(null), b.sourceBlock_.bumpNeighbours_()
    }
    return c
};
Blockly.cake.comment = function(a) {
    for (var b = "", c = "", d = 0, e = 0; e <= a.commentAddCount_; e++) {
        b = Blockly.cake.valueToCode(a, "VAR" + e, Blockly.cake.ORDER_NONE) || "";
        var f = a.inputList[e].connection,
            h = f.targetBlock();
        h && "library_stdio_text" != h.type && (f.isSuperior() ? f.targetBlock().setParent(null) : f.sourceBlock_.setParent(null), f.sourceBlock_.bumpNeighbours_());
        "" != b && (c += b + "\n");
        d += 1
    }
    return 1 == d ? "" != b ? "//" + c : "//\n" : "/*\n" + c + "*/\n"
};
Blockly.cake.time = {};
Blockly.cake.library_time_current = function(a) {
    a = a.getScope();
    Blockly.cake.times_.time_currentTime = [a, "struct tm *t;\ntime_t timer;"];
    Blockly.cake.definitions_.include_cake_time = "#include <time.h>";
    return 'timer = time(NULL);\nt = localtime(&timer);\nprintf("%04d-%02d-%02d %02d:%02d:%02d\\n",t->tm_year + 1900, t->tm_mon + 1, t->tm_mday, t->tm_hour, t->tm_min, t->tm_sec);\n'
};
Blockly.cake.library_time_requiredTime = function(a) {
    var b = Blockly.cake.valueToCode(a, "SAVE", Blockly.cake.ORDER_NONE) || "",
        c = Blockly.cake.statementToCode(a, "DO");
    a = a.getScope();
    Blockly.cake.times_.time_requiredTime = [a, "time_t start, end;"];
    Blockly.cake.definitions_.include_cake_time = "#include <time.h>";
    return "start = time(NULL);\n" + c + "end = time(NULL);\n" + b + " = difftime(end, start);\n"
};
Blockly.cake.stdlib = {};
Blockly.cake.library_stdlib_convert = function(a) {
    var b = a.getFieldValue("OPERATORS");
    a = Blockly.cake.valueToCode(a, "VAR", Blockly.cake.ORDER_NONE) || "''";
    switch (b) {
        case "INT":
            b = "atoi(" + a + ")";
            break;
        case "DOUBLE":
            b = "atof(" + a + ")";
            break;
        default:
            throw "Unknown math operator: " + b;
    }
    Blockly.cake.definitions_.include_cake_stdlib = "#include <stdlib.h>";
    return [b, Blockly.cake.ORDER_NONE]
};
Blockly.cake.library_stdlib_rand = function(a) {
    var b = Blockly.cake.valueToCode(a, "VAR", Blockly.cake.ORDER_NONE) || "";
    Blockly.cake.definitions_.include_cake_stdlib = "#include <stdlib.h>";
    Blockly.cake.definitions_.include_cake_time = "#include <time.h>";
    b = "rand()" + b;
    Blockly.cake.getUpperLine(a);
    return [b, Blockly.cake.ORDER_NONE]
};
Blockly.cake.getUpperLine = function(a) {
    a = a.getScope();
    Blockly.cake.times_.cake_time_srand = [a, "srand(time(NULL));"]
};
Blockly.cake.library_stdlib_rand_scope = function(a) {
    var b = Blockly.cake.valueToCode(a, "A", Blockly.cake.ORDER_NONE) || "0";
    a = Blockly.cake.valueToCode(a, "B", Blockly.cake.ORDER_NONE) || "0";
    return [1 == b ? " % " + a + " + " + b : " % (" + a + "-" + b + "+1) + " + b, Blockly.cake.ORDER_NONE]
};
Blockly.cake.library_stdlib_number_forRandScope1 = function(a) {
    return [parseFloat(a.getFieldValue("NUM")), Blockly.cake.ORDER_ATOMIC]
};
Blockly.cake.library_stdlib_number_forRandScope100 = function(a) {
    return [parseFloat(a.getFieldValue("NUM")), Blockly.cake.ORDER_ATOMIC]
};
Blockly.cake.library_stdlib_malloc = function(a) {
    var b = Blockly.FieldDropdown.prototype.getParentType(a, "variables_pointer");
    a = Blockly.cake.valueToCode(a, "VAR", Blockly.cake.ORDER_NONE) || "''";
    Blockly.cake.definitions_.include_cake_stdlib = "#include <stdlib.h>";
    return ["(" + b + " *)malloc(" + a + ")", Blockly.cake.ORDER_NONE]
};
Blockly.cake.library_stdlib_sizeof_forMalloc = function(a) {
    return ["sizeof(" + (Blockly.cake.valueToCode(a, "VAR", Blockly.cake.ORDER_NONE) || "''") + ")", Blockly.cake.ORDER_NONE]
};
Blockly.cake.library_stdlib_arithmetic_forMalloc = function(a) {
    var b = Blockly.cake.valueToCode(a, "A", Blockly.cake.ORDER_NONE) || "0";
    a = Blockly.cake.valueToCode(a, "B", Blockly.cake.ORDER_NONE) || "0";
    return [b + " * " + a, Blockly.cake.ORDER_NONE]
};
Blockly.cake.library_stdlib_number_forMalloc = function(a) {
    return [parseFloat(a.getFieldValue("NUM")), Blockly.cake.ORDER_ATOMIC]
};
Blockly.cake.library_stdlib_free = function(a) {
    a = Blockly.cake.valueToCode(a, "VAR", Blockly.cake.ORDER_NONE) || "''";
    Blockly.cake.definitions_.include_cake_stdlib = "#include <stdlib.h>";
    return "free(" + a + ");\n"
};
Blockly.cake.library_stdlib_exit = function(a) {
    a = a.getFieldValue("OPERATORS");
    switch (a) {
        case "SUCCESS":
            a = "exit(0);\n";
            break;
        case "FAILURE":
            a = "exit(1);\n";
            break;
        default:
            throw "Unknown math operator: " + a;
    }
    Blockly.cake.definitions_.include_cake_stdlib = "#include <stdlib.h>";
    return a
};
Blockly.cake.loops = {};
Blockly.cake.controls_whileUntil = function(a) {
    var b = "UNTIL" == a.getFieldValue("MODE"),
        c = Blockly.cake.valueToCode(a, "BOOL", b ? Blockly.cake.ORDER_LOGICAL_NOT : Blockly.cake.ORDER_NONE) || "0",
        d = Blockly.cake.statementToCode(a, "DO");
    d = Blockly.cake.addLoopTrap(d, a.id);
    b && (c = "!" + c);
    return "while (" + c + ") {\n" + d + "}\n"
};
Blockly.cake.controls_doWhile = function(a) {
    var b = "UNTIL" == a.getFieldValue("MODE"),
        c = Blockly.cake.valueToCode(a, "BOOL", b ? Blockly.cake.ORDER_LOGICAL_NOT : Blockly.cake.ORDER_NONE) || "0",
        d = Blockly.cake.statementToCode(a, "DO");
    d = Blockly.cake.addLoopTrap(d, a.id);
    b && (c = "!" + c);
    return "do {\n" + d + "} while (" + c + ");\n"
};
Blockly.cake.controls_for = function(a) {
    var b = Blockly.cake.variableDB_.getName(a.getFieldValue("VAR"), Blockly.Variables.NAME_TYPE);
    if ("___EC_84_A0_ED_83_9D__" == b || "--Select--" == b) b = "unselected";
    var c = Blockly.cake.valueToCode(a, "FROM", Blockly.cake.ORDER_ASSIGNMENT) || "0",
        d = Blockly.cake.valueToCode(a, "TO", Blockly.cake.ORDER_ASSIGNMENT) || "0",
        e = Blockly.cake.valueToCode(a, "BY", Blockly.cake.ORDER_ASSIGNMENT) || "1",
        f = Blockly.cake.statementToCode(a, "DO");
    f = Blockly.cake.addLoopTrap(f, a.id);
    a = "for (" + b + " = " + c +
        "; " + b + "<" + d + "; " + b;
    b = 0 <= e;
    e = Math.abs(parseFloat(e));
    return (1 == e ? a + (b ? "++" : "--") : a + ((b ? " += " : " -= ") + e)) + (") {\n" + f + "}\n")
};
Blockly.cake.controls_flow_statements = function(a) {
    switch (a.getFieldValue("FLOW")) {
        case "BREAK":
            return "break;\n";
        case "CONTINUE":
            return "continue;\n"
    }
    throw "Unknown flow statement.";
};
Blockly.cake.structure = {};
Blockly.cake.structure_define = function(a) {
    for (var b = Blockly.cake.variableDB_.getName(a.getFieldValue("NAME"), null), c = [], d = [], e = [], f = [], h = [], g = 0; g < a.members_.length; g++) c[g] = Blockly.cake.variableDB_.getName(a.members_[g], Blockly.Variables.NAME_TYPE), d[g] = a.types_[g], e[g] = a.dist_[g], f[g] = a.spec_[g], "v" == e[g] ? h[g] = d[g] + " " + c[g] + ";\n" : "a" == e[g] ? h[g] = d[g] + " " + c[g] + "[" + f[g] + "];\n" : "p" == e[g] && (h[g] = d[g] + f[g] + " " + c[g] + ";\n");
    a = "typedef struct\n{\n" + h.join("") + "} " + b + ";\n"; - 1 == Blockly.Blocks.checkLegalName(Blockly.Msg.STRUCTURE_ILLEGALNAME, b) &&
        this.initName();
    return a
};
Blockly.cake.structure_declare = function(a) {
    var b = Blockly.cake.variableDB_.getName(a.getFieldValue("TYPES"), null);
    b = Blockly.Blocks.checkUnselect(b);
    a = Blockly.cake.variableDB_.getName(a.getFieldValue("NAME"), Blockly.Variables.NAME_TYPE); - 1 == Blockly.Blocks.checkLegalName(Blockly.Msg.STRUCTURE_ILLEGALNAME, a) && this.initName();
    return b + " " + a + ";\n"
};
Blockly.cake.structure_get = function(a) {
    var b = Blockly.cake.variableDB_.getName(a.getFieldValue("NAME"), null);
    a = Blockly.cake.variableDB_.getName(a.getFieldValue("Mem"), Blockly.Variables.NAME_TYPE);
    a = Blockly.Blocks.checkUnselect(a);
    return ["Itself" == a ? b : b + "." + a, Blockly.cake.ORDER_ATOMIC]
};
Blockly.cake.structure_set = function(a) {
    var b = a.getFieldValue("NAME"),
        c = Blockly.cake.variableDB_.getName(a.getFieldValue("Mem"), Blockly.Variables.NAME_TYPE);
    c = Blockly.Blocks.checkUnselect(c);
    a = Blockly.cake.valueToCode(a, "VALUE", Blockly.cake.ORDER_ASSIGNMENT) || "0";
    return ("Itself" == c ? b : b + "." + c) + " = " + a + ";\n"
};
Blockly.cake.procedures = {};
Blockly.cake.main_block = function(a) {
    var b = Blockly.cake.statementToCode(a, "STACK");
    Blockly.cake.STATEMENT_PREFIX && (b = Blockly.cake.prefixLines(Blockly.cake.STATEMENT_PREFIX.replace(/%1/g, "'" + a.id + "'"), Blockly.cake.INDENT) + b);
    Blockly.cake.INFINITE_LOOP_TRAP && (b = Blockly.cake.INFINITE_LOOP_TRAP.replace(/%1/g, "'" + a.id + "'") + b);
    var c = Blockly.cake.valueToCode(a, "RETURN", Blockly.cake.ORDER_NONE) || "";
    c = c ? "  return " + c + ";\n" : "  return 0;\n";
    for (var d = [], e = [], f = [], h = 0; h < a.arguments_.length; h++) d[h] = Blockly.cake.variableDB_.getName(a.arguments_[h],
        Blockly.Variables.NAME_TYPE), e[h] = a.types_[h], f[h] = e[h] + " " + d[h];
    d = [];
    e = [];
    for (var g in Blockly.cake.times_) h = Blockly.cake.times_[g], g.match("srand") ? "main_block" == h[0] && (h = Blockly.cake.prefixLines(h[1], Blockly.cake.INDENT), d.push(h)) : g.match("time") && "main_block" == h[0] && (h = Blockly.cake.prefixLines(h[1], Blockly.cake.INDENT), e.push(h));
    g = d.length ? d.join("\n") + "\n" + e.join("\n") : e.join("\n");
    b = "int main(" + f.join(", ") + ") {" + g.replace(/\n\n+/g, "\n\n").replace(/\n*$/, "\n") + b + c + "}";
    b = Blockly.cake.scrub_(a,
        b);
    Blockly.cake.definitions_.main = b;
    return null
};
Blockly.cake.procedures_return = function(a) {
    return (a = a.getFieldValue("VALUE")) ? "return " + a + ";\n" : "return 0;\n"
};
Blockly.cake.procedures_defreturn = function(a) {
    var b = Blockly.cake.variableDB_.getName(a.getFieldValue("NAME"), Blockly.Procedures.NAME_TYPE),
        c = Blockly.cake.statementToCode(a, "STACK");
    Blockly.cake.STATEMENT_PREFIX && (c = Blockly.cake.prefixLines(Blockly.cake.STATEMENT_PREFIX.replace(/%1/g, "'" + a.id + "'"), Blockly.cake.INDENT) + c);
    Blockly.cake.INFINITE_LOOP_TRAP && (c = Blockly.cake.INFINITE_LOOP_TRAP.replace(/%1/g, "'" + a.id + "'") + c);
    var d = Blockly.cake.valueToCode(a, "RETURN", Blockly.cake.ORDER_NONE) || "";
    d = d ? "  return " +
        d + ";\n" : "  return 0;\n";
    var e = Blockly.Procedures.getTypePlusArgs(a),
        f = [],
        h = [];
    for (k in Blockly.cake.times_) {
        var g = Blockly.cake.times_[k];
        k.match("srand") ? g[0] == b && (g = Blockly.cake.prefixLines(g[1], Blockly.cake.INDENT), f.push(g)) : k.match("time") && g[0] == b && (g = Blockly.cake.prefixLines(g[1], Blockly.cake.INDENT), h.push(g))
    }
    h = f.length ? f.join("\n") + "\n" + h.join("\n") : h.join("\n");
    f = a.getFieldValue("TYPES");
    var k = a.getFieldValue("DISTS");
    "pointer" == k ? (k = a.getFieldValue("PSPECS"), null == k && (k = "*"), c = f + k + " " +
        b + "(" + e.join(", ") + ") {\n" + h.replace(/\n\n+/g, "\n\n").replace(/\n*$/, "\n") + c + d + "}") : "array" == k ? (k = a.getFieldValue("ASPECS"), null == k && (k = "[]"), c = f + k + " " + b + "(" + e.join(", ") + ") {\n" + h.replace(/\n\n+/g, "\n\n").replace(/\n*$/, "\n") + c + d + "}") : c = f + " " + b + "(" + e.join(", ") + ") {\n" + h.replace(/\n\n+/g, "\n\n").replace(/\n*$/, "\n") + c + d + "}";
    c = Blockly.cake.scrub_(a, c);
    Blockly.cake.definitions_[b] = c;
    Blockly.cake.definitions_["Func_declare" + b] = f + " " + b + "(" + e.join(", ") + ");"; - 1 == Blockly.Blocks.checkLegalName(Blockly.Msg.PROCEDURES_ILLEGALNAME,
        b) && this.initName();
    return null
};
Blockly.cake.procedures_defnoreturn = function(a) {
    var b = Blockly.cake.variableDB_.getName(a.getFieldValue("NAME"), Blockly.Procedures.NAME_TYPE),
        c = Blockly.cake.statementToCode(a, "STACK"),
        d = [],
        e = [],
        f;
    for (f in Blockly.cake.times_) {
        var h = Blockly.cake.times_[f];
        f.match("srand") ? h[0] == b && (h = Blockly.cake.prefixLines(h[1], Blockly.cake.INDENT), d.push(h)) : f.match("time") && h[0] == b && (h = Blockly.cake.prefixLines(h[1], Blockly.cake.INDENT), e.push(h))
    }
    e = d.length ? d.join("\n") + "\n" + e.join("\n") : e.join("\n");
    Blockly.cake.STATEMENT_PREFIX &&
        (c = Blockly.cake.prefixLines(Blockly.cake.STATEMENT_PREFIX.replace(/%1/g, "'" + a.id + "'"), Blockly.cake.INDENT) + c);
    Blockly.cake.INFINITE_LOOP_TRAP && (c = Blockly.cake.INFINITE_LOOP_TRAP.replace(/%1/g, "'" + a.id + "'") + c);
    (f = Blockly.cake.valueToCode(a, "RETURN", Blockly.cake.ORDER_NONE) || "") && (f = "  return " + f + ";\n");
    d = Blockly.Procedures.getTypePlusArgs(a);
    c = "void " + b + "(" + d.join(", ") + ") {\n" + e.replace(/\n\n+/g, "\n\n").replace(/\n*$/, "\n") + c + f + "}";
    c = Blockly.cake.scrub_(a, c);
    Blockly.cake.definitions_[b] = c;
    Blockly.cake.definitions_["Func_declare" +
        b] = "void " + b + "(" + d.join(", ") + ");"; - 1 == Blockly.Blocks.checkLegalName(Blockly.Msg.PROCEDURES_ILLEGALNAME, b) && this.initName();
    return null
};
Blockly.cake.procedures_callreturn = function(a) {
    for (var b = Blockly.cake.variableDB_.getName(a.getFieldValue("NAME"), Blockly.Procedures.NAME_TYPE), c = [], d = 0; d < a.arguments_.length; d++) c[d] = Blockly.cake.valueToCode(a, "ARG" + d, Blockly.cake.ORDER_COMMA) || "null";
    return [b + "(" + c.join(", ") + ")", Blockly.cake.ORDER_FUNCTION_CALL]
};
Blockly.cake.procedures_callnoreturn = function(a) {
    for (var b = Blockly.cake.variableDB_.getName(a.getFieldValue("NAME"), Blockly.Procedures.NAME_TYPE), c = [], d = 0; d < a.arguments_.length; d++) c[d] = Blockly.cake.valueToCode(a, "ARG" + d, Blockly.cake.ORDER_COMMA) || "null";
    return b + "(" + c.join(", ") + ");\n"
};
Blockly.cake.colour = {};
Blockly.cake.colour_picker = function(a) {
    return ["'" + a.getFieldValue("COLOUR") + "'", Blockly.cake.ORDER_ATOMIC]
};
Blockly.cake.colour_random = function(a) {
    return [Blockly.cake.provideFunction_("colour_random", ["function " + Blockly.cake.FUNCTION_NAME_PLACEHOLDER_ + "() {", "  var num = Math.floor(Math.random() * Math.pow(2, 24));", "  return '#' + ('00000' + num.toString(16)).substr(-6);", "}"]) + "()", Blockly.cake.ORDER_FUNCTION_CALL]
};
Blockly.cake.colour_rgb = function(a) {
    var b = Blockly.cake.valueToCode(a, "RED", Blockly.cake.ORDER_COMMA) || 0,
        c = Blockly.cake.valueToCode(a, "GREEN", Blockly.cake.ORDER_COMMA) || 0;
    a = Blockly.cake.valueToCode(a, "BLUE", Blockly.cake.ORDER_COMMA) || 0;
    return [Blockly.cake.provideFunction_("colour_rgb", ["function " + Blockly.cake.FUNCTION_NAME_PLACEHOLDER_ + "(r, g, b) {", "  r = Math.max(Math.min(Number(r), 100), 0) * 2.55;", "  g = Math.max(Math.min(Number(g), 100), 0) * 2.55;", "  b = Math.max(Math.min(Number(b), 100), 0) * 2.55;",
        "  r = ('0' + (Math.round(r) || 0).toString(16)).slice(-2);", "  g = ('0' + (Math.round(g) || 0).toString(16)).slice(-2);", "  b = ('0' + (Math.round(b) || 0).toString(16)).slice(-2);", "  return '#' + r + g + b;", "}"
    ]) + "(" + b + ", " + c + ", " + a + ")", Blockly.cake.ORDER_FUNCTION_CALL]
};
Blockly.cake.colour_blend = function(a) {
    var b = Blockly.cake.valueToCode(a, "COLOUR1", Blockly.cake.ORDER_COMMA) || "'#000000'",
        c = Blockly.cake.valueToCode(a, "COLOUR2", Blockly.cake.ORDER_COMMA) || "'#000000'";
    a = Blockly.cake.valueToCode(a, "RATIO", Blockly.cake.ORDER_COMMA) || .5;
    return [Blockly.cake.provideFunction_("colour_blend", ["function " + Blockly.cake.FUNCTION_NAME_PLACEHOLDER_ + "(c1, c2, ratio) {", "  ratio = Math.max(Math.min(Number(ratio), 1), 0);", "  var r1 = parseInt(c1.substring(1, 3), 16);", "  var g1 = parseInt(c1.substring(3, 5), 16);",
        "  var b1 = parseInt(c1.substring(5, 7), 16);", "  var r2 = parseInt(c2.substring(1, 3), 16);", "  var g2 = parseInt(c2.substring(3, 5), 16);", "  var b2 = parseInt(c2.substring(5, 7), 16);", "  var r = Math.round(r1 * (1 - ratio) + r2 * ratio);", "  var g = Math.round(g1 * (1 - ratio) + g2 * ratio);", "  var b = Math.round(b1 * (1 - ratio) + b2 * ratio);", "  r = ('0' + (r || 0).toString(16)).slice(-2);", "  g = ('0' + (g || 0).toString(16)).slice(-2);", "  b = ('0' + (b || 0).toString(16)).slice(-2);", "  return '#' + r + g + b;",
        "}"
    ]) + "(" + b + ", " + c + ", " + a + ")", Blockly.cake.ORDER_FUNCTION_CALL]
};